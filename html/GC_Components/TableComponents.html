<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>GC_Components.TableComponents API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>GC_Components.TableComponents</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Project Name:
# Glass Carbide
#
# By:
# Michael Gailling
# &amp;&amp;
# Mustafa Butt
#
# Organization:
# WIMTACH
#

import asyncio
import inspect
import sys
from PySide2.QtGui import QColor, Qt, QBrush
from PySide2.QtWidgets import QFrame, QTableWidget, QVBoxLayout, QTableWidgetItem, QApplication, QWidget, QComboBox, \
    QCheckBox, QHeaderView

#
# class DataTable(QFrame):
#     &#34;&#34;&#34;Data Table
#
#         Summary:
#             A class for a data table that includes:
#
#             -Method for altering cell bg color
#
#             -Method for altering cell text color
#
#             -Method for setting and getting cell values
#
#         Attributes:
#             vbox, mappings, selections, readonly, table, width, height
#
#         Methods:
#             clear_table, set_dimensions, set_headers, style_headers, insert_control_row, insert_control_column,
#             insert_data_column, create_control_widget, load_table, fit_headers_to_content, cell_changed,
#             set_cell_tooltip, set_cell_color, set_text_color, set_cell_widget, set_cell_text, get_cell_text
#
#         Attributes
#         ----------
#             vbox : QVBoxLayout
#                 Vertical Layout
#             mappings : []
#                 !!! Array of mappings of !!!
#             selections : []
#                 Array of selected rows and columns
#             readonly : bool
#                 Variable for whether cell is editable or readonly
#             table : QTableWidget
#                 Table to which data is loaded
#             width : int
#                 Width of table
#             height : int
#                 Height of table
#
#         Methods
#         -------
#             clear_table(self)
#                 Clears table contents
#             set_dimensions(self, width=0, height=0)
#                 Sets number of columns and rows in table
#             set_headers(self, headers)
#                 Sets table headers
#             style_headers(self)
#                 Sets styling for headers
#             insert_control_row(self, widget_type=None, start_index=0, options=[])
#                 Inserts control row in table
#             insert_control_column(self, widget_type=None, start_index=0, options=[])
#                 Inserts control column in table
#             insert_data_column(self, header=&#34;&#34;, start_index_y=0, insert_before=True, data=[])
#                 Inserts data by column
#             create_control_widget(self, widget_type=None, options=[])
#                 Inserts combo boxes if control row or check boxes if control column
#             load_table(self, data=[])
#                 Loads data to table
#             fit_headers_to_content(self)
#                 Sets header width to fit widest column
#             cell_changed(self, y, x)
#                 Slot for cell changed signal
#             set_cell_tooltip(self, x=0, y=0, tooltip_text=&#34;&#34;)
#                 Set tooltip for cell
#             set_cell_color(self, x=0, y=0, color=&#34;white&#34;)
#                 Sets the background color of the specified cell
#             set_text_color(self, x=0, y=0, color=&#34;black&#34;)
#                 Sets the text color of the specified cell
#             set_cell_widget(self,  widget=None, x=0, y=0,)
#                 Sets the cell&#39;s widget
#             set_cell_text(self, x=0, y=0, text=&#34;&#34;)
#                 Sets the text of the specified cell
#             get_cell_text(self, x=0, y=0)
#                 Gets the text of the specified cell
#     &#34;&#34;&#34;
#
#     def __init__(self, parent=None, width=0, height=0, readonly=False, log_data=False):
#         &#34;&#34;&#34;
#         Constructs all the necessary attributes for the Data Table object.
#
#         Parameters
#         ----------
#             self
#             parent : QFrame
#             width : int
#                 The number of columns
#             height : int
#                 The number of rows
#             readonly : bool
#                 Set readonly status
#             log_data : bool
#                 Set log recording status
#         &#34;&#34;&#34;
#         super(DataTable, self).__init__(parent)
#
#         self.headers =[]
#
#         self.mappings = []
#         self.selections = []
#         self.readonly = readonly
#
#         self.table = QTableWidget()
#         self.width = width
#         self.height = height
#         self.set_dimensions(width, height)
#
#         if log_data:
#             self.table.cellChanged.connect(self.cell_changed)
#         self.table.verticalHeader().hide()
#
#         self.vbox = QVBoxLayout()
#         self.vbox.addWidget(self.table)
#
#         self.setLayout(self.vbox)
#
#     def clear_table(self):
#         self.table.clear()
#
#     def set_dimensions(self, width=0, height=0):
#         self.width = width
#         self.height = height
#         self.table.setColumnCount(width)
#         self.table.setRowCount(height)
#
#     def get_dimensions(self):
#         return {&#34;x&#34;: self.width, &#34;y&#34;: self.height}
#
#     def set_headers(self, headers):
#         self.headers = headers
#         self.table.setHorizontalHeaderLabels(headers)
#         self.table.horizontalHeader().setStyleSheet(&#39;color:#1000A0&#39;)
#         self.style_headers()
#
#     def get_headers(self):
#         return self.headers
#
#     def style_headers(self):
#         self.table.horizontalHeader().setStyleSheet(&#34;::section{background-color:#1000A0;color:white;font-weight:bold}&#34;)
#         self.table.horizontalHeader().setAutoFillBackground(True)
#
#     def insert_row(self):
#         pass
#
#     def add_row(self):
#         pass
#
#     def insert_control_row(self, widget_type=None, start_index=0, options=[]):
#         self.table.insertRow(0)
#
#         self.height += 1
#
#         if widget_type:
#             width = self.width
#             self.mappings = []
#             for x in range(start_index, width):
#                 self.mappings.append(self.create_control_widget(widget_type, options))
#                 self.set_cell_widget(self.mappings[-1], x, 0)
#
#     def insert_control_column(self, widget_type=None, start_index=0, options=[]):
#         self.table.insertColumn(0)
#
#         self.width += 1
#
#         if widget_type:
#             height = self.height
#             self.selections = []
#             for y in range(start_index, height):
#                 self.selections.append(self.create_control_widget(widget_type, options))
#                 self.set_cell_widget(self.selections[-1], 0, y)
#
#     def insert_data_column(self, header=&#34;&#34;, start_index_y=0, insert_before=True, data=[]):
#         header_item = QTableWidgetItem(header)
#         if insert_before:
#             self.table.insertColumn(0)
#             self.table.setHorizontalHeaderItem(0, header_item)
#             for y in range(start_index_y, len(data)):
#                 cell = QTableWidgetItem(data[y])
#                 self.table.setItem(y, 0, cell)
#         else:
#             self.table.insertColumn(self.width)
#             self.table.setHorizontalHeaderItem(self.width, header_item)
#             for y in range(start_index_y, len(data)):
#                 cell = QTableWidgetItem(data[y])
#                 self.table.setItem(y, self.width, cell)
#         self.width += 1
#
#     def create_control_widget(self, widget_type=None, options=[]):
#         if widget_type == &#34;combobox&#34;:
#             widget = QComboBox()
#
#             widget.setEditable(True)
#
#             if options:
#                 widget.addItems(options)
#
#         elif widget_type == &#34;checkbox&#34;:
#             widget = QCheckBox(self)
#
#         return widget
#
#     def load_table(self, data=[]):
#
#         data_type = type(data[0])
#         if data_type is str:
#             height = len(data)
#
#             self.set_dimensions(1, height)
#
#             for y in range(height):
#                 cell = QTableWidgetItem(data[y])
#                 if self.readonly:
#                     cell.setFlags(Qt.ItemIsEditable)
#                 self.table.setItem(y, 0, cell)
#
#             asyncio.run(self.fit_headers_to_content())
#         else:
#             height = len(data)
#             width = len(data[0])
#             self.set_dimensions(width, height)
#
#             for y in range(height):
#                 for x in range(width):
#                     cell = QTableWidgetItem(data[y][x])
#                     if self.readonly:
#                         cell.setFlags(Qt.ItemIsEditable)
#                     self.table.setItem(y, x, cell)
#
#         # asyncio.run(self.fit_headers_to_content())
#
#     def get_table_data(self):
#         table_data = []
#
#         for y in range(self.height):
#             table_row = []
#
#             for x in range(self.width):
#                 table_row.append(self.get_cell_text(x, y))
#
#             table_data.append(table_row)
#
#         return table_data
#
#     async def fit_headers_to_content(self):
#         header = self.table.horizontalHeader()
#         width = self.table.columnCount()
#         for i in range(width):
#             header.setSectionResizeMode(i, QHeaderView.ResizeToContents)
#
#     def cell_changed(self, y=0, x=0):
#         &#34;&#34;&#34;
#         Slot for handling cell change events
#
#         Parameters
#         ----------
#         x : int
#             Cell X co-ordinate
#         y: int
#             Cell Y co-ordinate
#
#         Returns
#         -------
#         None
#         &#34;&#34;&#34;
#         asyncio.run(self.log_cell(x, y))
#
#     def set_cell_tooltip(self, x=0, y=0, tooltip_text=&#34;&#34;):
#         self.table.item(y, x).setToolTip(tooltip_text)
#
#     def set_cell_color(self, x=0, y=0, color=&#34;white&#34;):
#         &#34;&#34;&#34;
#         Method for setting the bg color of a cell
#
#         Parameters
#         ----------
#         x : int
#             Cell X co-ordinate
#         y: int
#             Cell Y co-ordinate
#         color : string
#             Color as to set cell background color
#
#         Returns
#         -------
#         None
#         &#34;&#34;&#34;
#         self.table.item(y, x).setBackgroundColor(QColor(color))
#
#     def set_text_color(self, x=0, y=0, color=&#34;black&#34;):
#         &#34;&#34;&#34;
#         Method for setting the text color of a cell
#
#         Parameters
#         ----------
#         x : int
#             Cell X co-ordinate
#         y: int
#             Cell Y co-ordinate
#         color : string
#             Color to set cell text color
#
#         Returns
#         -------
#         None
#         &#34;&#34;&#34;
#         self.table.item(y, x).setTextColor(QColor(color))
#
#     def set_cell_widget(self,  widget=None, x=0, y=0,):
#         self.table.setCellWidget(y, x, widget)
#
#     def set_cell_text(self, x=0, y=0, text=&#34;&#34;):
#         &#34;&#34;&#34;
#         Method for setting the text content of a cell
#
#         Parameters
#         ----------
#         x : int
#             Cell X co-ordinate
#         y: int
#             Cell Y co-ordinate
#         text : string
#             Text to set cell content
#
#         Returns
#         -------
#         None
#         &#34;&#34;&#34;
#         cell = QTableWidgetItem(text)
#         self.table.setItem(y, x, cell)
#
#     def get_cell_text(self, x=0, y=0):
#         &#34;&#34;&#34;
#         Method for Getting the text content of a cell
#
#         Parameters
#         ----------
#         x : int
#             Cell X co-ordinate
#         y: int
#             Cell Y co-ordinate
#
#         Returns
#         -------
#         text_content : string
#             Text content of specified cell
#         &#34;&#34;&#34;
#         text_content = self.table.item(y, x).text()
#         return text_content
#
#     async def log_cell(self, x=0, y=0):
#         &#34;&#34;&#34;
#         Method for logging the current state of a cell to console
#
#         Parameters
#         ----------
#         x : int
#             Cell X co-ordinate
#         y: int
#             Cell Y co-ordinate
#
#         Returns
#         -------
#         None
#         &#34;&#34;&#34;
#         cell_text = self.get_cell_text(x, y)
#         bg_color_red = str(self.table.item(y, x).backgroundColor().red())
#         bg_color_green = str(self.table.item(y, x).backgroundColor().green())
#         bg_color_blue = str(self.table.item(y, x).backgroundColor().blue())
#         bg_color_alpha = str(self.table.item(y, x).backgroundColor().alpha())
#         text_color_red = str(self.table.item(y, x).textColor().red())
#         text_color_green = str(self.table.item(y, x).textColor().green())
#         text_color_blue = str(self.table.item(y, x).textColor().blue())
#         text_color_alpha = str(self.table.item(y, x).textColor().alpha())
#
#         print()
#         print()
#
#         print(&#34;Cell Changed&#34;)
#         print(&#34;-------------------------------------&#34;)
#         print(&#34;x:&#34; + str(x) + &#34; y:&#34; + str(y))
#         print()
#
#         print(&#34;Cell Data&#34;)
#         print(&#34;-------------------------------------&#34;)
#         print(cell_text)
#         print()
#
#         print(&#34;Background Color&#34;)
#         print(&#34;-------------------------------------&#34;)
#         print(&#34;RED: &#34; + bg_color_red + &#34; GREEN: &#34; + bg_color_green + &#34; BLUE: &#34; + bg_color_blue +
#               &#34; ALPHA: &#34; + bg_color_alpha)
#         print()
#
#         print(&#34;Text Color&#34;)
#         print(&#34;-------------------------------------&#34;)
#         print(&#34;RED: &#34; + text_color_red + &#34; GREEN: &#34; + text_color_green + &#34; BLUE: &#34; + text_color_blue +
#               &#34; ALPHA: &#34; + text_color_alpha)
#
#         print()
#         print()

#
# class SimpleDataTable(DataTable):
#     &#34;&#34;&#34;Asset Data Table
#
#         Summary:
#             A class for loading assets in a data table
#
#         Attributes:
#             mappings, data, readonly
#
#         Methods:
#             load_table
#
#         Attributes
#         ----------
#             mappings : []
#                 !!! Array of mappings of !!!
#             data : []
#                 Array of data from selected column
#             readonly : bool
#                 Variable for whether cell is editable or readonly
#
#         Methods
#         -------
#             load_table(self, data=[])
#                 Loads passed in array of assets in DataTable
#     &#34;&#34;&#34;
#
#     def __init__(self,  parent=None, width=0, height=0, readonly=False, log_data=False):
#         &#34;&#34;&#34;
#             Constructs all the necessary attributes for the AssetDataTable object.
#
#             Parameters
#             ----------
#                 self
#                 parent : DataTable
#                 width : int
#                     The number of columns
#                 height : int
#                     The number of rows
#                 readonly : bool
#                     Set readonly status
#                 log_data : bool
#                     Set log recording status
#         &#34;&#34;&#34;
#         super(SimpleDataTable, self).__init__(parent)
#         self.readonly = readonly
#         self.data = []
#         self.mappings = []
#
#     def load_table(self, data=[]):
#         height = len(data)
#
#         self.set_dimensions(1, height)
#
#         for y in range(height):
#             cell = QTableWidgetItem(data[y])
#             if self.readonly:
#                 cell.setFlags(Qt.ItemIsEditable)
#             self.table.setItem(y, 0, cell)
#
#         asyncio.run(self.fit_headers_to_content())



class DataTable(QFrame):

    def __init__(self, parent=None, width=0, height=0, readonly=False, log_data=False):
        super(DataTable, self).__init__(parent)

        self.headers = []

        self.data = []

        self.readonly = readonly

        self.table = QTableWidget()
        self.width = 0
        self.height = 0
        self.set_dimensions(width, height)

        if log_data:
            self.table.cellChanged.connect(self.cell_changed)
        self.table.verticalHeader().hide()

        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.table)

        self.setLayout(self.vbox)

    # Utility functions
    def clear_table(self):
        self.table.clear()

    def set_dimensions(self, width=0, height=0):
        self.width = width
        self.height = height
        self.table.setColumnCount(width)
        self.table.setRowCount(height)

    def get_dimensions(self):
        return {&#34;x&#34;: self.width, &#34;y&#34;: self.height}

    def set_headers(self, headers):
        self.headers = headers
        self.table.setHorizontalHeaderLabels(headers)
        self.table.horizontalHeader().setStyleSheet(&#39;color:#1000A0&#39;)
        self.style_headers()

    def get_headers(self):
        return self.headers

    def style_headers(self, style=&#34;::section{background-color:#1000A0;color:white;font-weight:bold}&#34;):
        self.table.horizontalHeader().setStyleSheet(style)
        self.table.horizontalHeader().setAutoFillBackground(True)

    def is_standard_var(self, var):
        var_type = type(var)

        if var_type is str:
            return True
        if var_type is int:
            return True
        if var_type is float:
            return True
        if var_type is complex:
            return True

    def build_combo(self, var):
        combo = QComboBox(self)
        combo.addItems(var)

        return combo

    def set_cell_tooltip(self, x=0, y=0, tooltip_text=&#34;&#34;):
        self.table.item(y, x).setToolTip(tooltip_text)

    def set_cell_color(self, x=0, y=0, color=&#34;white&#34;):
        &#34;&#34;&#34;
        Method for setting the bg color of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate
        color : string
            Color as to set cell background color

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.table.item(y, x).setBackgroundColor(QColor(color))

    def set_text_color(self, x=0, y=0, color=&#34;black&#34;):
        &#34;&#34;&#34;
        Method for setting the text color of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate
        color : string
            Color to set cell text color

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.table.item(y, x).setTextColor(QColor(color))

    # Table data functions
    def add_row(self, row=[]):
        row_len = len(row)

        # General state of row parameter
        is_list = (type(row) is list)
        wider_than_table = (row_len &gt; self.width)
        is_empty = (row_len == 0)

        if is_list:
            if not wider_than_table:
                y_index = self.height

                # Create blank row in table
                self.table.insertRow(y_index)

                # Add items to row in table
                for x_index in range(row_len):
                    contents = row[x_index]
                    if self.is_standard_var(contents):
                        contents = str(contents)
                        cell = QTableWidgetItem(contents)
                        if self.readonly:
                            cell.setFlags(Qt.ItemIsEditable)
                        self.table.setItem(y_index, x_index, cell)
                    elif type(contents) is bool:
                        check = QCheckBox(self)
                        check.setChecked(contents)
                        self.table.setCellWidget(y_index, x_index, check)
                    elif type(contents) is list:
                        combo = self.build_combo(contents)
                        self.table.setCellWidget(y_index, x_index, combo)
                self.height += 1

            else:
                raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)

    def insert_row(self, row=[], y_index=0):
        row_len = len(row)

        # State of row parameter
        is_list = (type(row) is list)
        wider_than_table = (row_len &gt; self.width)

        # State of y_index
        index_within_bounds = (y_index &lt; self.height)

        if is_list:
            if not wider_than_table:
                if index_within_bounds:
                    # Create blank row in table
                    self.table.insertRow(y_index)

                    # Add items to row in table
                    for x_index in range(row_len):
                        contents = row[x_index]
                        if self.is_standard_var(contents):
                            contents = str(contents)
                            cell = QTableWidgetItem(contents)
                            if self.readonly:
                                cell.setFlags(Qt.ItemIsEditable)
                            self.table.setItem(y_index, x_index, cell)
                        elif type(contents) is bool:
                            check = QCheckBox(self)
                            check.setChecked(contents)
                            self.table.setCellWidget(y_index, x_index, check)
                        elif type(contents) is list:
                            combo = self.build_combo(contents)
                            self.table.setCellWidget(y_index, x_index, combo)
                    self.height += 1
                else:
                    raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)
            else:
                raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)

    def set_row(self, row=[], y_index=0):
        row_len = len(row)

        # State of row parameter
        is_list = (type(row) is list)
        wider_than_table = (row_len &gt; self.width)

        # State of y_index
        index_within_bounds = (y_index &lt; self.height)

        if is_list:
            if not wider_than_table:
                if index_within_bounds:
                    for x_index in range(row_len):
                        contents = row[x_index]
                        if self.is_standard_var(contents):
                            contents = str(contents)
                            cell = QTableWidgetItem(contents)
                            if self.readonly:
                                cell.setFlags(Qt.ItemIsEditable)
                            self.table.setItem(y_index, x_index, cell)
                        elif type(contents) is bool:
                            check = QCheckBox(self)
                            check.setChecked(contents)
                            self.table.setCellWidget(y_index, x_index, check)
                        elif type(contents) is list:
                            combo = self.build_combo(contents)
                            self.table.setCellWidget(y_index, x_index, combo)
                else:
                    raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)
            else:
                raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)

    def get_row(self, y_index=0):
        # State of y_index
        index_within_bounds = (y_index &lt; self.height)
        width = self.width

        row = []

        if index_within_bounds:
            for x_index in range(width):
                try:
                    cell = self.table.item(y_index, x_index)
                    cell_text = cell.text()
                    row.append(cell_text)
                except:
                    cell = self.table.cellWidget(y_index, x_index)
                    if isinstance(cell, QComboBox):
                        cell = cell.currentText()
                    elif isinstance(cell, QCheckBox):
                        cell = cell.isChecked()
                    row.append(cell)
            return row
        else:
            raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)

    def remove_row(self, y_index=0):
        # State of y_index
        index_within_bounds = (y_index &lt; self.height)

        if index_within_bounds:
            self.table.removeRow(y_index)
            self.height -= 1
        else:
            raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)

    def load_table(self, data_arr=[]):
        try:
            width = len(data_arr[0])
            height = len(data_arr)

            self.set_dimensions(width)

            for item in data_arr:
                self.add_row(item)
        except IndexError as e:
            pass

    def get_all_rows(self):
        rows = []
        for y in range(self.height):
            rows.append(self.get_row(y))

        return rows

    def set_cell_text(self, x=0, y=0, text=&#34;&#34;):
        &#34;&#34;&#34;
        Method for setting the text content of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate
        text : string
            Text to set cell content

        Returns
        -------
        None
        &#34;&#34;&#34;
        cell = QTableWidgetItem(text)
        self.table.setItem(y, x, cell)

    def get_cell_text(self, x=0, y=0):
        &#34;&#34;&#34;
        Method for Getting the text content of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate

        Returns
        -------
        text_content : string
            Text content of specified cell
        &#34;&#34;&#34;
        text_content = self.table.item(y, x).text()
        return text_content


if __name__ == &#39;__main__&#39;:
    qApp = QApplication(sys.argv)
    dt_table = DataTable(readonly=False)
    dt_table.set_dimensions(5)
    dt_table.set_headers([&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;])
    dt_table.style_headers()

    mapping_options = [&#34;option&#34;, &#34;option&#34;, &#34;option&#34;, &#34;option&#34;, &#34;option&#34;, &#34;option&#34;]
    mapping_row = [mapping_options, mapping_options, mapping_options, mapping_options, mapping_options]
    test_arr = [
                    mapping_row,
                    [False, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;],
                    [False, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;],
                    [False, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;],
                    [False, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;, &#34;OLD&#34;],
                ]

    dt_table.show()

    dt_table.load_table(test_arr)

    for i in range(dt_table.height):
        print(dt_table.get_row(i))

    sys.exit(qApp.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="GC_Components.TableComponents.DataTable"><code class="flex name class">
<span>class <span class="ident">DataTable</span></span>
<span>(</span><span>parent=None, width=0, height=0, readonly=False, log_data=False)</span>
</code></dt>
<dd>
<div class="desc"><p>QFrame(self, parent: typing.Union[PySide2.QtWidgets.QWidget, NoneType] = None, f: PySide2.QtCore.Qt.WindowFlags = Default(Qt.WindowFlags)) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTable(QFrame):

    def __init__(self, parent=None, width=0, height=0, readonly=False, log_data=False):
        super(DataTable, self).__init__(parent)

        self.headers = []

        self.data = []

        self.readonly = readonly

        self.table = QTableWidget()
        self.width = 0
        self.height = 0
        self.set_dimensions(width, height)

        if log_data:
            self.table.cellChanged.connect(self.cell_changed)
        self.table.verticalHeader().hide()

        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.table)

        self.setLayout(self.vbox)

    # Utility functions
    def clear_table(self):
        self.table.clear()

    def set_dimensions(self, width=0, height=0):
        self.width = width
        self.height = height
        self.table.setColumnCount(width)
        self.table.setRowCount(height)

    def get_dimensions(self):
        return {&#34;x&#34;: self.width, &#34;y&#34;: self.height}

    def set_headers(self, headers):
        self.headers = headers
        self.table.setHorizontalHeaderLabels(headers)
        self.table.horizontalHeader().setStyleSheet(&#39;color:#1000A0&#39;)
        self.style_headers()

    def get_headers(self):
        return self.headers

    def style_headers(self, style=&#34;::section{background-color:#1000A0;color:white;font-weight:bold}&#34;):
        self.table.horizontalHeader().setStyleSheet(style)
        self.table.horizontalHeader().setAutoFillBackground(True)

    def is_standard_var(self, var):
        var_type = type(var)

        if var_type is str:
            return True
        if var_type is int:
            return True
        if var_type is float:
            return True
        if var_type is complex:
            return True

    def build_combo(self, var):
        combo = QComboBox(self)
        combo.addItems(var)

        return combo

    def set_cell_tooltip(self, x=0, y=0, tooltip_text=&#34;&#34;):
        self.table.item(y, x).setToolTip(tooltip_text)

    def set_cell_color(self, x=0, y=0, color=&#34;white&#34;):
        &#34;&#34;&#34;
        Method for setting the bg color of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate
        color : string
            Color as to set cell background color

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.table.item(y, x).setBackgroundColor(QColor(color))

    def set_text_color(self, x=0, y=0, color=&#34;black&#34;):
        &#34;&#34;&#34;
        Method for setting the text color of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate
        color : string
            Color to set cell text color

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.table.item(y, x).setTextColor(QColor(color))

    # Table data functions
    def add_row(self, row=[]):
        row_len = len(row)

        # General state of row parameter
        is_list = (type(row) is list)
        wider_than_table = (row_len &gt; self.width)
        is_empty = (row_len == 0)

        if is_list:
            if not wider_than_table:
                y_index = self.height

                # Create blank row in table
                self.table.insertRow(y_index)

                # Add items to row in table
                for x_index in range(row_len):
                    contents = row[x_index]
                    if self.is_standard_var(contents):
                        contents = str(contents)
                        cell = QTableWidgetItem(contents)
                        if self.readonly:
                            cell.setFlags(Qt.ItemIsEditable)
                        self.table.setItem(y_index, x_index, cell)
                    elif type(contents) is bool:
                        check = QCheckBox(self)
                        check.setChecked(contents)
                        self.table.setCellWidget(y_index, x_index, check)
                    elif type(contents) is list:
                        combo = self.build_combo(contents)
                        self.table.setCellWidget(y_index, x_index, combo)
                self.height += 1

            else:
                raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)

    def insert_row(self, row=[], y_index=0):
        row_len = len(row)

        # State of row parameter
        is_list = (type(row) is list)
        wider_than_table = (row_len &gt; self.width)

        # State of y_index
        index_within_bounds = (y_index &lt; self.height)

        if is_list:
            if not wider_than_table:
                if index_within_bounds:
                    # Create blank row in table
                    self.table.insertRow(y_index)

                    # Add items to row in table
                    for x_index in range(row_len):
                        contents = row[x_index]
                        if self.is_standard_var(contents):
                            contents = str(contents)
                            cell = QTableWidgetItem(contents)
                            if self.readonly:
                                cell.setFlags(Qt.ItemIsEditable)
                            self.table.setItem(y_index, x_index, cell)
                        elif type(contents) is bool:
                            check = QCheckBox(self)
                            check.setChecked(contents)
                            self.table.setCellWidget(y_index, x_index, check)
                        elif type(contents) is list:
                            combo = self.build_combo(contents)
                            self.table.setCellWidget(y_index, x_index, combo)
                    self.height += 1
                else:
                    raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)
            else:
                raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)

    def set_row(self, row=[], y_index=0):
        row_len = len(row)

        # State of row parameter
        is_list = (type(row) is list)
        wider_than_table = (row_len &gt; self.width)

        # State of y_index
        index_within_bounds = (y_index &lt; self.height)

        if is_list:
            if not wider_than_table:
                if index_within_bounds:
                    for x_index in range(row_len):
                        contents = row[x_index]
                        if self.is_standard_var(contents):
                            contents = str(contents)
                            cell = QTableWidgetItem(contents)
                            if self.readonly:
                                cell.setFlags(Qt.ItemIsEditable)
                            self.table.setItem(y_index, x_index, cell)
                        elif type(contents) is bool:
                            check = QCheckBox(self)
                            check.setChecked(contents)
                            self.table.setCellWidget(y_index, x_index, check)
                        elif type(contents) is list:
                            combo = self.build_combo(contents)
                            self.table.setCellWidget(y_index, x_index, combo)
                else:
                    raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)
            else:
                raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)

    def get_row(self, y_index=0):
        # State of y_index
        index_within_bounds = (y_index &lt; self.height)
        width = self.width

        row = []

        if index_within_bounds:
            for x_index in range(width):
                try:
                    cell = self.table.item(y_index, x_index)
                    cell_text = cell.text()
                    row.append(cell_text)
                except:
                    cell = self.table.cellWidget(y_index, x_index)
                    if isinstance(cell, QComboBox):
                        cell = cell.currentText()
                    elif isinstance(cell, QCheckBox):
                        cell = cell.isChecked()
                    row.append(cell)
            return row
        else:
            raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)

    def remove_row(self, y_index=0):
        # State of y_index
        index_within_bounds = (y_index &lt; self.height)

        if index_within_bounds:
            self.table.removeRow(y_index)
            self.height -= 1
        else:
            raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)

    def load_table(self, data_arr=[]):
        try:
            width = len(data_arr[0])
            height = len(data_arr)

            self.set_dimensions(width)

            for item in data_arr:
                self.add_row(item)
        except IndexError as e:
            pass

    def get_all_rows(self):
        rows = []
        for y in range(self.height):
            rows.append(self.get_row(y))

        return rows

    def set_cell_text(self, x=0, y=0, text=&#34;&#34;):
        &#34;&#34;&#34;
        Method for setting the text content of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate
        text : string
            Text to set cell content

        Returns
        -------
        None
        &#34;&#34;&#34;
        cell = QTableWidgetItem(text)
        self.table.setItem(y, x, cell)

    def get_cell_text(self, x=0, y=0):
        &#34;&#34;&#34;
        Method for Getting the text content of a cell

        Parameters
        ----------
        x : int
            Cell X co-ordinate
        y: int
            Cell Y co-ordinate

        Returns
        -------
        text_content : string
            Text content of specified cell
        &#34;&#34;&#34;
        text_content = self.table.item(y, x).text()
        return text_content</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PySide2.QtWidgets.QFrame</li>
<li>PySide2.QtWidgets.QWidget</li>
<li>PySide2.QtCore.QObject</li>
<li>PySide2.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="GC_Components.TableComponents.DataTable.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="GC_Components.TableComponents.DataTable.add_row"><code class="name flex">
<span>def <span class="ident">add_row</span></span>(<span>self, row=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_row(self, row=[]):
    row_len = len(row)

    # General state of row parameter
    is_list = (type(row) is list)
    wider_than_table = (row_len &gt; self.width)
    is_empty = (row_len == 0)

    if is_list:
        if not wider_than_table:
            y_index = self.height

            # Create blank row in table
            self.table.insertRow(y_index)

            # Add items to row in table
            for x_index in range(row_len):
                contents = row[x_index]
                if self.is_standard_var(contents):
                    contents = str(contents)
                    cell = QTableWidgetItem(contents)
                    if self.readonly:
                        cell.setFlags(Qt.ItemIsEditable)
                    self.table.setItem(y_index, x_index, cell)
                elif type(contents) is bool:
                    check = QCheckBox(self)
                    check.setChecked(contents)
                    self.table.setCellWidget(y_index, x_index, check)
                elif type(contents) is list:
                    combo = self.build_combo(contents)
                    self.table.setCellWidget(y_index, x_index, combo)
            self.height += 1

        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
    else:
        raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.build_combo"><code class="name flex">
<span>def <span class="ident">build_combo</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_combo(self, var):
    combo = QComboBox(self)
    combo.addItems(var)

    return combo</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.clear_table"><code class="name flex">
<span>def <span class="ident">clear_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_table(self):
    self.table.clear()</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.get_all_rows"><code class="name flex">
<span>def <span class="ident">get_all_rows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_rows(self):
    rows = []
    for y in range(self.height):
        rows.append(self.get_row(y))

    return rows</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.get_cell_text"><code class="name flex">
<span>def <span class="ident">get_cell_text</span></span>(<span>self, x=0, y=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for Getting the text content of a cell</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell X co-ordinate</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell Y co-ordinate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>text_content</code></strong> :&ensp;<code>string</code></dt>
<dd>Text content of specified cell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell_text(self, x=0, y=0):
    &#34;&#34;&#34;
    Method for Getting the text content of a cell

    Parameters
    ----------
    x : int
        Cell X co-ordinate
    y: int
        Cell Y co-ordinate

    Returns
    -------
    text_content : string
        Text content of specified cell
    &#34;&#34;&#34;
    text_content = self.table.item(y, x).text()
    return text_content</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.get_dimensions"><code class="name flex">
<span>def <span class="ident">get_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dimensions(self):
    return {&#34;x&#34;: self.width, &#34;y&#34;: self.height}</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.get_headers"><code class="name flex">
<span>def <span class="ident">get_headers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_headers(self):
    return self.headers</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.get_row"><code class="name flex">
<span>def <span class="ident">get_row</span></span>(<span>self, y_index=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_row(self, y_index=0):
    # State of y_index
    index_within_bounds = (y_index &lt; self.height)
    width = self.width

    row = []

    if index_within_bounds:
        for x_index in range(width):
            try:
                cell = self.table.item(y_index, x_index)
                cell_text = cell.text()
                row.append(cell_text)
            except:
                cell = self.table.cellWidget(y_index, x_index)
                if isinstance(cell, QComboBox):
                    cell = cell.currentText()
                elif isinstance(cell, QCheckBox):
                    cell = cell.isChecked()
                row.append(cell)
        return row
    else:
        raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.insert_row"><code class="name flex">
<span>def <span class="ident">insert_row</span></span>(<span>self, row=[], y_index=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_row(self, row=[], y_index=0):
    row_len = len(row)

    # State of row parameter
    is_list = (type(row) is list)
    wider_than_table = (row_len &gt; self.width)

    # State of y_index
    index_within_bounds = (y_index &lt; self.height)

    if is_list:
        if not wider_than_table:
            if index_within_bounds:
                # Create blank row in table
                self.table.insertRow(y_index)

                # Add items to row in table
                for x_index in range(row_len):
                    contents = row[x_index]
                    if self.is_standard_var(contents):
                        contents = str(contents)
                        cell = QTableWidgetItem(contents)
                        if self.readonly:
                            cell.setFlags(Qt.ItemIsEditable)
                        self.table.setItem(y_index, x_index, cell)
                    elif type(contents) is bool:
                        check = QCheckBox(self)
                        check.setChecked(contents)
                        self.table.setCellWidget(y_index, x_index, check)
                    elif type(contents) is list:
                        combo = self.build_combo(contents)
                        self.table.setCellWidget(y_index, x_index, combo)
                self.height += 1
            else:
                raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
    else:
        raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.is_standard_var"><code class="name flex">
<span>def <span class="ident">is_standard_var</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_standard_var(self, var):
    var_type = type(var)

    if var_type is str:
        return True
    if var_type is int:
        return True
    if var_type is float:
        return True
    if var_type is complex:
        return True</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.load_table"><code class="name flex">
<span>def <span class="ident">load_table</span></span>(<span>self, data_arr=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_table(self, data_arr=[]):
    try:
        width = len(data_arr[0])
        height = len(data_arr)

        self.set_dimensions(width)

        for item in data_arr:
            self.add_row(item)
    except IndexError as e:
        pass</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.remove_row"><code class="name flex">
<span>def <span class="ident">remove_row</span></span>(<span>self, y_index=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_row(self, y_index=0):
    # State of y_index
    index_within_bounds = (y_index &lt; self.height)

    if index_within_bounds:
        self.table.removeRow(y_index)
        self.height -= 1
    else:
        raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_cell_color"><code class="name flex">
<span>def <span class="ident">set_cell_color</span></span>(<span>self, x=0, y=0, color='white')</span>
</code></dt>
<dd>
<div class="desc"><p>Method for setting the bg color of a cell</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell X co-ordinate</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell Y co-ordinate</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>string</code></dt>
<dd>Color as to set cell background color</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell_color(self, x=0, y=0, color=&#34;white&#34;):
    &#34;&#34;&#34;
    Method for setting the bg color of a cell

    Parameters
    ----------
    x : int
        Cell X co-ordinate
    y: int
        Cell Y co-ordinate
    color : string
        Color as to set cell background color

    Returns
    -------
    None
    &#34;&#34;&#34;
    self.table.item(y, x).setBackgroundColor(QColor(color))</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_cell_text"><code class="name flex">
<span>def <span class="ident">set_cell_text</span></span>(<span>self, x=0, y=0, text='')</span>
</code></dt>
<dd>
<div class="desc"><p>Method for setting the text content of a cell</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell X co-ordinate</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell Y co-ordinate</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>Text to set cell content</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell_text(self, x=0, y=0, text=&#34;&#34;):
    &#34;&#34;&#34;
    Method for setting the text content of a cell

    Parameters
    ----------
    x : int
        Cell X co-ordinate
    y: int
        Cell Y co-ordinate
    text : string
        Text to set cell content

    Returns
    -------
    None
    &#34;&#34;&#34;
    cell = QTableWidgetItem(text)
    self.table.setItem(y, x, cell)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_cell_tooltip"><code class="name flex">
<span>def <span class="ident">set_cell_tooltip</span></span>(<span>self, x=0, y=0, tooltip_text='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell_tooltip(self, x=0, y=0, tooltip_text=&#34;&#34;):
    self.table.item(y, x).setToolTip(tooltip_text)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_dimensions"><code class="name flex">
<span>def <span class="ident">set_dimensions</span></span>(<span>self, width=0, height=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dimensions(self, width=0, height=0):
    self.width = width
    self.height = height
    self.table.setColumnCount(width)
    self.table.setRowCount(height)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_headers"><code class="name flex">
<span>def <span class="ident">set_headers</span></span>(<span>self, headers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_headers(self, headers):
    self.headers = headers
    self.table.setHorizontalHeaderLabels(headers)
    self.table.horizontalHeader().setStyleSheet(&#39;color:#1000A0&#39;)
    self.style_headers()</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_row"><code class="name flex">
<span>def <span class="ident">set_row</span></span>(<span>self, row=[], y_index=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_row(self, row=[], y_index=0):
    row_len = len(row)

    # State of row parameter
    is_list = (type(row) is list)
    wider_than_table = (row_len &gt; self.width)

    # State of y_index
    index_within_bounds = (y_index &lt; self.height)

    if is_list:
        if not wider_than_table:
            if index_within_bounds:
                for x_index in range(row_len):
                    contents = row[x_index]
                    if self.is_standard_var(contents):
                        contents = str(contents)
                        cell = QTableWidgetItem(contents)
                        if self.readonly:
                            cell.setFlags(Qt.ItemIsEditable)
                        self.table.setItem(y_index, x_index, cell)
                    elif type(contents) is bool:
                        check = QCheckBox(self)
                        check.setChecked(contents)
                        self.table.setCellWidget(y_index, x_index, check)
                    elif type(contents) is list:
                        combo = self.build_combo(contents)
                        self.table.setCellWidget(y_index, x_index, combo)
            else:
                raise Exception(&#34;Invalid Parameter: y_index is out of bounds!&#34;)
        else:
            raise Exception(&#34;Invalid Parameter: Row parameter is wider than table!&#34;)
    else:
        raise Exception(&#34;Invalid Parameter: Row parameter is not a list!&#34;)</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, x=0, y=0, color='black')</span>
</code></dt>
<dd>
<div class="desc"><p>Method for setting the text color of a cell</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell X co-ordinate</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell Y co-ordinate</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>string</code></dt>
<dd>Color to set cell text color</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text_color(self, x=0, y=0, color=&#34;black&#34;):
    &#34;&#34;&#34;
    Method for setting the text color of a cell

    Parameters
    ----------
    x : int
        Cell X co-ordinate
    y: int
        Cell Y co-ordinate
    color : string
        Color to set cell text color

    Returns
    -------
    None
    &#34;&#34;&#34;
    self.table.item(y, x).setTextColor(QColor(color))</code></pre>
</details>
</dd>
<dt id="GC_Components.TableComponents.DataTable.style_headers"><code class="name flex">
<span>def <span class="ident">style_headers</span></span>(<span>self, style='::section{background-color:#1000A0;color:white;font-weight:bold}')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def style_headers(self, style=&#34;::section{background-color:#1000A0;color:white;font-weight:bold}&#34;):
    self.table.horizontalHeader().setStyleSheet(style)
    self.table.horizontalHeader().setAutoFillBackground(True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="GC_Components" href="index.html">GC_Components</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="GC_Components.TableComponents.DataTable" href="#GC_Components.TableComponents.DataTable">DataTable</a></code></h4>
<ul class="two-column">
<li><code><a title="GC_Components.TableComponents.DataTable.add_row" href="#GC_Components.TableComponents.DataTable.add_row">add_row</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.build_combo" href="#GC_Components.TableComponents.DataTable.build_combo">build_combo</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.clear_table" href="#GC_Components.TableComponents.DataTable.clear_table">clear_table</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.get_all_rows" href="#GC_Components.TableComponents.DataTable.get_all_rows">get_all_rows</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.get_cell_text" href="#GC_Components.TableComponents.DataTable.get_cell_text">get_cell_text</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.get_dimensions" href="#GC_Components.TableComponents.DataTable.get_dimensions">get_dimensions</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.get_headers" href="#GC_Components.TableComponents.DataTable.get_headers">get_headers</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.get_row" href="#GC_Components.TableComponents.DataTable.get_row">get_row</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.insert_row" href="#GC_Components.TableComponents.DataTable.insert_row">insert_row</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.is_standard_var" href="#GC_Components.TableComponents.DataTable.is_standard_var">is_standard_var</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.load_table" href="#GC_Components.TableComponents.DataTable.load_table">load_table</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.remove_row" href="#GC_Components.TableComponents.DataTable.remove_row">remove_row</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_cell_color" href="#GC_Components.TableComponents.DataTable.set_cell_color">set_cell_color</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_cell_text" href="#GC_Components.TableComponents.DataTable.set_cell_text">set_cell_text</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_cell_tooltip" href="#GC_Components.TableComponents.DataTable.set_cell_tooltip">set_cell_tooltip</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_dimensions" href="#GC_Components.TableComponents.DataTable.set_dimensions">set_dimensions</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_headers" href="#GC_Components.TableComponents.DataTable.set_headers">set_headers</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_row" href="#GC_Components.TableComponents.DataTable.set_row">set_row</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.set_text_color" href="#GC_Components.TableComponents.DataTable.set_text_color">set_text_color</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.staticMetaObject" href="#GC_Components.TableComponents.DataTable.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="GC_Components.TableComponents.DataTable.style_headers" href="#GC_Components.TableComponents.DataTable.style_headers">style_headers</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>